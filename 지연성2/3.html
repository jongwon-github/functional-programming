<script>
  const log = console.log;
</script>
<script src="../lib/fx.js"></script>
<script>
  const isIterable = (a) => a && a[Symbol.iterator];

  /* 표현1 */
  L.flatten = function* (iter) {
    for (const a of iter) {
      if (isIterable(a)) for (const b of a) yield b;
      else yield a;
    }
  };

  const it = L.flatten([[11, 21], 3, [1, 2, 3]]);
  log(it.next());
  log(it.next());
  log(it.next());
  log(take(6, L.flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]])));

  const flatten = pipe(L.flatten, takeAll);
  log(flatten([[1, 2], 3, 4, [5, 6], [7, 8, 9]]));

  /* 표현2 : 표현1의 for문을 'yield*'로 변경 */
  L.flatten2 = function* (iter) {
    for (const a of iter) {
      if (isIterable(a)) yield* a;
      else yield a;
    }
  };
  log([...L.flatten2([[1, 2], 3, 4, [5, 6], [7, 8, 9]])]);

  /* 깊은 iterable을 모두 펼치고 싶을 경우 사용 */
  /* 기명함수를 통한 재귀호출 */
  L.deepFlat = function* f(iter) {
    for (const a of iter) {
      if (isIterable(a)) yield* f(a);
      else yield a;
    }
  };
  log([...L.deepFlat([1, [2, [3, 4, [5]]]])]);

  // 왜 이렇게 되는지 모르겠음...
  L.flatMap = curry(pipe(L.map, L.flatten));
  var fm = L.flatMap(
    map((a) => a * a),
    [
      [1, 2],
      [3, 4],
      [5, 6, 7],
    ]
  );
  log([...fm]);
  const flatMap = pipe(L.map, flatten);
  log(
    flatMap(
      (a) => a * a,
      [
        [1, 2],
        [3, 4],
        [5, 6, 7],
      ]
    )
  );
</script>
<body></body>
