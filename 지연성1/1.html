<script>const log = console.log;</script>
<script src="../lib/fx.js"></script>
<script>
    /* 
        range 실행 시에 while문이 실행되고 배열을 return 한다.
        그리고 reduce 실행 시에도 내부적으로 acc[Symbol.iterator]()를 통해 이터레이터를 만드는 로직을 수행할 때 
        배열에서 이터레이터로 변환 작업 필요
    */
    const range = l => {
        let i = -1;
        let res = [];
        while (++i < l) {
            res.push(i);
        }
        return res;
    };

    var list = range(4);
    log(list);
    log(reduce(add, list));

    /* 
        느긋한 L.range 
        L.range 실행 시에는 실제로 while문이 실행되지 않는다.
        reduce 실행 시에 while문이 실행됨.
        그리고 reduce 실행 시에도 내부적으로 acc[Symbol.iterator]()를 통해 이터레이터를 만드는 로직 수행할 때
        변환 작업 불필요 
    */
    const L = {};
    L.range = function *(l) {
        let i = -1;
        while (++i < l) {
            yield i;
        }
    };

    var list = L.range(4);
    log(list);
    log(reduce(add, list));
</script>
<script>
    /* range와 느긋한 L.range 테스트 */
    console.clear();
    function test(name, time, f) {
        console.time(name);
        while (time--) f();
        console.timeEnd(name);
    }
    test('range', 10, () => reduce(add, range(1000000)));
    test('L.range', 10, () => reduce(add, L.range(1000000)));
</script>
<script>
    /* take */
    console.clear();
    const take = curry((l, iter) => {
        let res = [];
        for (const a of iter) {
            res.push(a);
            if (res.length == l) return res;
        }
        return res;
    });
    console.time('');
    go(
        range(100000),
        take(5),
        log);
    console.timeEnd('');
    console.time('');
    log(take(5, L.range(100000)));
    console.timeEnd('');
</script>
<body></body>